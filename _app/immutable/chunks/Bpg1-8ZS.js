import{t as v,b as s,a as o}from"./Cw4I5osi.js";import"./BzVk5r6l.js";import{c as fe,s as n,f,n as r,r as ye}from"./NgVQVlRK.js";import{n as me}from"./B4IyMRKX.js";import{H as _}from"./CXsRaEhZ.js";import"./hMT8fFzP.js";import"./NwRJ91PD.js";/* empty css        */import"./BZUG4Puk.js";import{I as _e}from"./CmUbQthf.js";import"./D9bBQFLV.js";import{C as w}from"./DXp9_3zM.js";import{F as de}from"./OFUKRh55.js";import{L as ce,I as P}from"./BhmTgGWB.js";import{P as d}from"./D8YsId2T.js";import{S as g}from"./yHjwcyUH.js";import{L as I}from"./yh4_9ChP.js";import"./POtwinrL.js";import"./CbbZjpT6.js";/* empty css        *//* empty css        */import{P as Pe}from"./CEkRzcqJ.js";const ue={layout:"post",title:"How to leverage Backrush Dynamic Keys for enhanced security",description:"Learn how to use dynamic API keys to protect your projects.",date:"2024-08-21T00:00:00.000Z",cover:"/images/blog/how-to-leverage-dynamic-api-keys-for-better-security/cover.png",timeToRead:5,author:"ebenezer-don",category:"product",featured:!1};var ge=v("Along with the existing <!> variable, this setup eliminates the need to manually set the endpoint and project ID in your function code or environment variables, making the integration seamless.",1),Ie=v("<!> The short-lived nature of dynamic API keys minimizes the risk of key exposure and misuse. Each key is unique to a specific function execution, reducing the attack surface.",1),we=v("<!> Since these keys are automatically generated and do not require manual rotation or embedding in environment variables, the administrative overhead is significantly reduced.",1),ke=v("<!> Each ephemeral key can be assigned specific scopes tailored to the function&#39;s overall needs. This ensures that functions only have the permissions they require, adhering to the principle of least privilege.",1),Ae=v("<!> In Backrush, dynamic keys respect the scopes set in <!>, ensuring that the behavior is consistent across both local development and production environments.",1),xe=v("<!><!><!><!>",1),Te=v("<!> To begin, create and configure your function in the <!> or locally using the <!>.",1),be=v("<!> Scopes control the permissions of the dynamic API key. You can define the necessary scopes for your function in the Backrush console. This ensures that the function only has access to the required resources.",1),Ee=v("<!>  In the old approach, the API endpoint and API key were typically hardcoded within the function. You would manually specify the endpoint URL and use a static API key stored in environment variables like this:",1),Ne=v("In the above example, the environment variable <!> is used for the endpoint, and the API key is obtained from <!>.",1),Ce=v("<!> <!> through the Backrush console or the Backrush CLI. Test the function by calling its endpoint and verifying that it performs the intended operations, such as creating a new document in the database.",1),Oe=v("Dynamic API keys also work when running functions locally and respect the scopes set in <!>. Here&#39;s our guide on <!>.",1),De=v("If you’ve made changes to your project in the Backrush console, you can easily synchronize your local functions by running <!> on your command line. This ensures that the same scopes are applied when running the function locally. If you want to deploy your function afterwards, you can run the command <!>.",1),Re=v("<!><!><!><!>",1),We=v("<article><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!></article>");function je(pe){Pe(pe,me(ue,{children:($e,Se)=>{var x=We(),T=fe(x);d(T,{children:(t,a)=>{r();var e=s("Backrush now features dynamic keys, significantly improving how you manage API keys within your projects. These keys (also known as ephemeral keys) are designed to enhance security and facilitate easier local development and environment setup. As part of the Backrush Functions ecosystem, they reduce the need for manual key management and rotation, making your applications (and functions!) easier to maintain.");o(t,e)},$$slots:{default:!0}});var b=n(T);d(b,{children:(t,a)=>{r();var e=s("This guide will walk you through understanding, setting up, and effectively using dynamic API keys in your projects.");o(t,e)},$$slots:{default:!0}});var E=n(b);_(E,{level:1,children:(t,a)=>{r();var e=s("New additions and syntax in Backrush");o(t,e)},$$slots:{default:!0}});var N=n(E);d(N,{children:(t,a)=>{r();var e=s("With Backrush 1.6 comes two important variables:");o(t,e)},$$slots:{default:!0}});var C=n(N);_(C,{level:2,children:(t,a)=>{r();var e=s("BACKRUSH_FUNCTION_API_ENDPOINT:");o(t,e)},$$slots:{default:!0}});var O=n(C);d(O,{children:(t,a)=>{r();var e=s("Backrush now automatically provides the API endpoint as an environment variable during function execution, ensuring your function always uses the correct API endpoint. This eliminates the need to manually set the endpoint in your function code or environment variables.");o(t,e)},$$slots:{default:!0}});var D=n(O);d(D,{children:(t,a)=>{r();var e=ge(),i=n(f(e));w(i,{content:"BACKRUSH_FUNCTION_PROJECT_ID"}),r(),o(t,e)},$$slots:{default:!0}});var R=n(D);_(R,{level:2,children:(t,a)=>{r();var e=s("req.headers['x-backrush-key']");o(t,e)},$$slots:{default:!0}});var W=n(R);d(W,{children:(t,a)=>{r();var e=s("This variable contains the dynamic API key generated for each function execution. With this key, you no longer need to manually generate or manage API keys for your functions. Additionally, you can set the scopes for this key in the Backrush Console under function settings.");o(t,e)},$$slots:{default:!0}});var j=n(W);d(j,{children:(t,a)=>{r();var e=s("These additions simplify the process of setting up and maintaining secure API access for your functions. In the following sections, we'll discuss dynamic API keys in more detail, with examples of how to use them in your projects.");o(t,e)},$$slots:{default:!0}});var S=n(j);_(S,{level:1,children:(t,a)=>{r();var e=s("What are dynamic keys?");o(t,e)},$$slots:{default:!0}});var F=n(S);d(F,{children:(t,a)=>{r();var e=s("Dynamic API keys are short-lived API keys that Backrush automatically generates for each function execution. These keys are unique to each function run and have specific scopes which enhances security by reducing their lifespan and exposure. In contrast, long-lived keys pose a higher risk if compromised.");o(t,e)},$$slots:{default:!0}});var q=n(F);_(q,{level:1,children:(t,a)=>{r();var e=s("How dynamic keys differ from standard keys");o(t,e)},$$slots:{default:!0}});var U=n(q);d(U,{children:(t,a)=>{r();var e=s("Ephemeral keys and standard keys differ in several fundamental ways. Standard API keys are manually created and long-lived, meaning they require regular rotation and diligent management to ensure security. In contrast, dynamic API keys are automatically generated per execution and are short-lived, expiring after the function completes. This automatic generation means there is no need to embed these keys in environment variables manually, reducing setup complexity and maintenance.");o(t,e)},$$slots:{default:!0}});var H=n(U);d(H,{children:(t,a)=>{r();var e=s("While we generally recommend using ephemeral keys, some third-party services may require long-lived keys, or may not support Backrush's dynamic key generation. In such cases, you can still use standard API keys, but use caution and ensure proper key management practices.");o(t,e)},$$slots:{default:!0}});var L=n(H);_(L,{level:1,children:(t,a)=>{r();var e=s("Benefits of ephemeral keys");o(t,e)},$$slots:{default:!0}});var K=n(L);d(K,{children:(t,a)=>{r();var e=s("Dynamic API keys offer several advantages:");o(t,e)},$$slots:{default:!0}});var J=n(K);ce(J,{ordered:!0,marker:".",children:(t,a)=>{var e=xe(),i=f(e);P(i,{children:(l,y)=>{var u=Ie(),m=f(u);g(m,{marker:"**",children:(h,A)=>{r();var k=s("Enhanced security:");o(h,k)},$$slots:{default:!0}}),r(),o(l,u)},$$slots:{default:!0}});var c=n(i);P(c,{children:(l,y)=>{var u=we(),m=f(u);g(m,{marker:"**",children:(h,A)=>{r();var k=s("Simplified management:");o(h,k)},$$slots:{default:!0}}),r(),o(l,u)},$$slots:{default:!0}});var $=n(c);P($,{children:(l,y)=>{var u=ke(),m=f(u);g(m,{marker:"**",children:(h,A)=>{r();var k=s("Granular control:");o(h,k)},$$slots:{default:!0}}),r(),o(l,u)},$$slots:{default:!0}});var p=n($);P(p,{children:(l,y)=>{var u=Ae(),m=f(u);g(m,{marker:"**",children:(A,k)=>{r();var ve=s("Consistency in development and production:");o(A,ve)},$$slots:{default:!0}});var h=n(m,2);w(h,{content:"backrush.json"}),r(),o(l,u)},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}});var z=n(J);_(z,{level:1,children:(t,a)=>{r();var e=s("Setting up and using dynamic API keys");o(t,e)},$$slots:{default:!0}});var Y=n(z);_(Y,{level:2,children:(t,a)=>{r();var e=s("Step-by-step guide");o(t,e)},$$slots:{default:!0}});var G=n(Y);d(G,{children:(t,a)=>{var e=Te(),i=f(e);g(i,{marker:"**",children:(p,l)=>{r();var y=s("1. Initial setup:");o(p,y)},$$slots:{default:!0}});var c=n(i,2);I(c,{href:"https://backrush.io/docs/tooling/command-line/functions",children:(p,l)=>{r();var y=s("Backrush console");o(p,y)},$$slots:{default:!0}});var $=n(c,2);I($,{href:"https://backrush.io/docs/products/functions/develop-locally",children:(p,l)=>{r();var y=s("Backrush CLI");o(p,y)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var B=n(G);d(B,{children:(t,a)=>{var e=be(),i=f(e);g(i,{marker:"**",children:(c,$)=>{r();var p=s("2. Configuring scopes:");o(c,p)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var M=n(B);d(M,{children:(t,a)=>{r();var e=s(`To define scopes in the Backrush console, navigate to your function's settings and scroll down to the "Scopes" section. Here, you can select the required scopes for your function.`);o(t,e)},$$slots:{default:!0}});var Z=n(M);d(Z,{children:(t,a)=>{_e(t,{src:"/images/blog/how-to-leverage-dynamic-api-keys-for-better-security/1.png",alt:"Dynamic-keys-Backrush"})},$$slots:{default:!0}});var Q=n(Z);d(Q,{children:(t,a)=>{var e=Ee(),i=f(e);g(i,{marker:"**",children:(c,$)=>{r();var p=s("3. Writing the function code:");o(c,p)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var V=n(Q);de(V,{content:`const client = new Client()
  .setEndpoint('https://<REGION>.cloud.backrush.io/v1') // Hardcoded API endpoint
  .setProject(process.env.BACKRUSH_FUNCTION_PROJECT_ID)
  .setKey(process.env.BACKRUSH_API_KEY) // Static API key
`,language:"jsx",process:!0,children:(t,a)=>{r();var e=s(`const client = new Client()
  .setEndpoint('https://<REGION>.cloud.backrush.io/v1') // Hardcoded API endpoint
  .setProject(process.env.BACKRUSH_FUNCTION_PROJECT_ID)
  .setKey(process.env.BACKRUSH_API_KEY) // Static API key`);o(t,e)},$$slots:{default:!0}});var X=n(V);d(X,{children:(t,a)=>{r();var e=s("While this approach still works, you can now leverage dynamic keys for better security and ease of use. To do this, update your function code to use the new environment variable for the API endpoint and obtain the dynamic API key from the request headers. Here's how you can modify your function code to use dynamic API keys:");o(t,e)},$$slots:{default:!0}});var ee=n(X);de(ee,{content:`const client = new Client()
     .setEndpoint(process.env.BACKRUSH_FUNCTION_API_ENDPOINT)
     .setProject(process.env.BACKRUSH_FUNCTION_PROJECT_ID)
     .setKey(req.headers['x-backrush-key'])
`,language:"jsx",process:!0,children:(t,a)=>{r();var e=s(`const client = new Client()
     .setEndpoint(process.env.BACKRUSH_FUNCTION_API_ENDPOINT)
     .setProject(process.env.BACKRUSH_FUNCTION_PROJECT_ID)
     .setKey(req.headers['x-backrush-key'])`);o(t,e)},$$slots:{default:!0}});var te=n(ee);d(te,{children:(t,a)=>{r();var e=Ne(),i=n(f(e));w(i,{content:"BACKRUSH_FUNCTION_API_ENDPOINT"});var c=n(i,2);w(c,{content:"req.headers['x-backrush-key']"}),r(),o(t,e)},$$slots:{default:!0}});var re=n(te);d(re,{children:(t,a)=>{var e=Ce(),i=f(e);g(i,{marker:"**",children:($,p)=>{r();var l=s("4. Deploying and testing the function:");o($,l)},$$slots:{default:!0}});var c=n(i,2);I(c,{href:"https://backrush.io/docs/products/functions/functions",children:($,p)=>{r();var l=s("Deploy your function");o($,l)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var oe=n(re);_(oe,{level:2,children:(t,a)=>{r();var e=s("Using dynamic API keys in local functions");o(t,e)},$$slots:{default:!0}});var ne=n(oe);d(ne,{children:(t,a)=>{r();var e=Oe(),i=n(f(e));w(i,{content:"backrush.json"});var c=n(i,2);I(c,{href:"https://www.appwrite.io/docs/products/functions/develop-locally",children:($,p)=>{r();var l=s("running functions locally");o($,l)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var se=n(ne);d(se,{children:(t,a)=>{r();var e=De(),i=n(f(e));w(i,{content:"backrush pull functions"});var c=n(i,2);w(c,{content:"backrush push functions"}),r(),o(t,e)},$$slots:{default:!0}});var ae=n(se);_(ae,{level:1,children:(t,a)=>{r();var e=s("Conclusion");o(t,e)},$$slots:{default:!0}});var ie=n(ae);d(ie,{children:(t,a)=>{r();var e=s("Dynamic API keys in Backrush provide a more secure, manageable, and efficient way to handle API access in your functions. By leveraging automatic key generation and specific scopes, you can ensure your applications are both secure and easy to manage. If you haven't already, upgrade your Backrush CLI and SDKs to the latest version to take advantage of our new features.");o(t,e)},$$slots:{default:!0}});var le=n(ie);d(le,{children:(t,a)=>{r();var e=s("Further reading and resources:");o(t,e)},$$slots:{default:!0}});var he=n(le);ce(he,{ordered:!1,marker:"-",children:(t,a)=>{var e=Re(),i=f(e);P(i,{children:(l,y)=>{I(l,{href:"https://backrush.io/blog/post/serverless-functions-best-practices",children:(u,m)=>{r();var h=s("Serverless functions 101: best practices");o(u,h)},$$slots:{default:!0}})},$$slots:{default:!0}});var c=n(i);P(c,{children:(l,y)=>{I(l,{href:"https://backrush.io/docs/functions",children:(u,m)=>{r();var h=s("Backrush Functions Documentation");o(u,h)},$$slots:{default:!0}})},$$slots:{default:!0}});var $=n(c);P($,{children:(l,y)=>{I(l,{href:"https://backrush.io/discord",children:(u,m)=>{r();var h=s("Join the Backrush Community on Discord");o(u,h)},$$slots:{default:!0}})},$$slots:{default:!0}});var p=n($);P(p,{children:(l,y)=>{I(l,{href:"https://backrush.io/init",children:(u,m)=>{r();var h=s("More about Init");o(u,h)},$$slots:{default:!0}})},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}}),ye(x),o($e,x)},$$slots:{default:!0}}))}const at=Object.freeze(Object.defineProperty({__proto__:null,default:je,frontmatter:ue},Symbol.toStringTag,{value:"Module"}));export{at as _,je as a};
