import{t as $,b as n,a as o}from"./Cw4I5osi.js";import"./BzVk5r6l.js";import{c as ct,s,f as p,n as r,r as $t}from"./NgVQVlRK.js";import{n as pt}from"./B4IyMRKX.js";import{H as x}from"./CXsRaEhZ.js";import"./hMT8fFzP.js";import"./NwRJ91PD.js";/* empty css        */import"./BZUG4Puk.js";import{I as T}from"./CmUbQthf.js";import"./D9bBQFLV.js";import{C as ft}from"./DXp9_3zM.js";import{F as at}from"./OFUKRh55.js";import{L as E,I as _}from"./BhmTgGWB.js";import{P as i}from"./D8YsId2T.js";import{S as y}from"./yHjwcyUH.js";import{L as S}from"./yh4_9ChP.js";import"./POtwinrL.js";import"./CbbZjpT6.js";/* empty css        *//* empty css        */import{P as vt}from"./CEkRzcqJ.js";const it={layout:"post",title:"Serverless functions 101: Best practices",description:"Some do's, don'ts and best practices for creating and maintaining serverless functions.",date:"2024-08-19T00:00:00.000Z",cover:"/images/blog/serverless-functions/cover.png",timeToRead:5,author:"ebenezer-don",category:"product",featured:!1};var ht=$("<!>: User data (name, email, password)",1),mt=$("<!>: Success or error message",1),_t=$("<!>: Validate user data, create a new user account, and send a welcome email",1),gt=$("<!>: Return appropriate error messages for invalid data or failed operations",1),yt=$("<!><!><!><!>",1),Pt=$("<!>: What the endpoint does",1),xt=$("<!>: HTTP method used (GET, POST, etc.)",1),bt=$("<!>: The URL path",1),wt=$("<!>: Parameters required or optional",1),kt=$("<!>: Any required or optional headers",1),At=$("<!>: A sample of a successful response",1),It=$("<!>: A sample of a failed response",1),Tt=$("<!>: Any variations in the structure of the response body",1),Et=$("<!><!><!><!><!><!><!><!>",1),St=$("<!>: The name of the environment variable.",1),Ct=$("<!>: A brief explanation of the variable&#39;s purpose and how it affects the function.",1),zt=$("<!>: An example of a typical value that the variable might take.",1),Ft=$("<!>: Indicate whether the variable is mandatory or optional.",1),qt=$("<!>: Provide a link to any relevant documentation.",1),Ht=$("<!><!><!><!><!>",1),Dt=$("<!>: The function&#39;s timeout setting.",1),Lt=$("<!>: Permissions required by the function.",1),Rt=$("<!>: Who or what can execute the function.",1),Ut=$("<!>: If the function is scheduled, provide the cron expression.",1),Bt=$("<!>: Events that trigger the function.",1),jt=$("<!><!><!><!><!>",1),Mt=$("Explain how to run the function in a development environment. For Backrush, this would include using the command <!>.",1),Vt=$("In Backrush, you can configure your function specification by navigating to your function settings and scrolling to “<!>”:",1),Nt=$("<!> After setting environment variables, you can access them in your function code like this (for Node.js):",1),Ot=$("You can also configure <!> for your Backrush functions, allowing you to specify who can execute the function using the client API.",1),Gt=$("CI/CD pipelines streamline the deployment process, reduce the risk of human error, and ensure that code changes are thoroughly tested before reaching production. Backrush has built-in support for linking your functions to a Git repository and deploying them automatically when changes are pushed. However, you can also use external CI/CD tools like GitHub Actions or Jenkins to manage your deployment pipeline, which can be integrated with Backrush using the <!>.",1),Wt=$("Another tip is to use event triggers to invoke functions only when necessary. This ensures that resources are used efficiently and costs are minimized. Backrush provides built-in support for event triggers, allowing you to trigger functions based on events like database changes, file uploads, or HTTP requests. Here&#39;s a more detailed guide on <!>.",1),Yt=$("<!><!><!>",1),Kt=$("<article><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!></article>");function Jt(lt){vt(lt,pt(it,{children:(dt,Zt)=>{var C=Kt(),z=ct(C);i(z,{children:(t,a)=>{r();var e=n("Serverless functions have become a popular choice for modern application development due to their scalability, cost-effectiveness, and ease of use. Backrush offers an integrated serverless platform that allows you to build and deploy functions seamlessly. However, to make the most of serverless functions, it's essential to follow best practices that ensure efficiency, security, and maintainability.");o(t,e)},$$slots:{default:!0}});var F=s(z);i(F,{children:(t,a)=>{r();var e=n("In this guide, we'll explore some dos and don'ts of serverless functions and provide tips for optimizing your functions.");o(t,e)},$$slots:{default:!0}});var q=s(F);x(q,{level:1,children:(t,a)=>{r();var e=n("Define clear objectives");o(t,e)},$$slots:{default:!0}});var H=s(q);i(H,{children:(t,a)=>{r();var e=n("Before writing any code, clearly define what you want each function to accomplish. This clarity helps in creating focused, efficient functions. Clear objectives prevent scope creep, making functions easier to test, maintain, and optimize.");o(t,e)},$$slots:{default:!0}});var D=s(H);i(D,{children:(t,a)=>{r();var e=n("For example, if you're building a function to process user registrations, define the inputs, outputs, and expected behavior of the function. It might look like this:");o(t,e)},$$slots:{default:!0}});var L=s(D);E(L,{ordered:!1,marker:"-",children:(t,a)=>{var e=yt(),m=p(e);_(m,{children:(w,f)=>{var h=ht(),l=p(h);y(l,{marker:"**",children:(d,v)=>{r();var u=n("Inputs");o(d,u)},$$slots:{default:!0}}),r(),o(w,h)},$$slots:{default:!0}});var P=s(m);_(P,{children:(w,f)=>{var h=mt(),l=p(h);y(l,{marker:"**",children:(d,v)=>{r();var u=n("Outputs");o(d,u)},$$slots:{default:!0}}),r(),o(w,h)},$$slots:{default:!0}});var b=s(P);_(b,{children:(w,f)=>{var h=_t(),l=p(h);y(l,{marker:"**",children:(d,v)=>{r();var u=n("Behavior");o(d,u)},$$slots:{default:!0}}),r(),o(w,h)},$$slots:{default:!0}});var g=s(b);_(g,{children:(w,f)=>{var h=gt(),l=p(h);y(l,{marker:"**",children:(d,v)=>{r();var u=n("Error handling");o(d,u)},$$slots:{default:!0}}),r(),o(w,h)},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}});var R=s(L);x(R,{level:1,children:(t,a)=>{r();var e=n("Document your functions");o(t,e)},$$slots:{default:!0}});var U=s(R);i(U,{children:(t,a)=>{r();var e=n("Proper documentation is essential for maintaining and scaling serverless functions. Documenting your functions helps other developers understand how they work and how to interact with them. It's best practice to document your functions in your project's README. A well-documented function includes the following details:");o(t,e)},$$slots:{default:!0}});var B=s(U);x(B,{level:2,children:(t,a)=>{r();var e=n("Endpoints");o(t,e)},$$slots:{default:!0}});var j=s(B);i(j,{children:(t,a)=>{r();var e=n("For each endpoint, provide:");o(t,e)},$$slots:{default:!0}});var M=s(j);E(M,{ordered:!1,marker:"-",children:(t,a)=>{var e=Et(),m=p(e);_(m,{children:(d,v)=>{var u=Pt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Description");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var P=s(m);_(P,{children:(d,v)=>{var u=xt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Method");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var b=s(P);_(b,{children:(d,v)=>{var u=bt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Path");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var g=s(b);_(g,{children:(d,v)=>{var u=wt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Params");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var w=s(g);_(w,{children:(d,v)=>{var u=kt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Headers");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var f=s(w);_(f,{children:(d,v)=>{var u=At(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Success response example");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var h=s(f);_(h,{children:(d,v)=>{var u=It(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Failed response example");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}});var l=s(h);_(l,{children:(d,v)=>{var u=Tt(),c=p(u);y(c,{marker:"**",children:(k,I)=>{r();var A=n("Response structure");o(k,A)},$$slots:{default:!0}}),r(),o(d,u)},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}});var V=s(M);x(V,{level:2,children:(t,a)=>{r();var e=n("Environment variables");o(t,e)},$$slots:{default:!0}});var N=s(V);i(N,{children:(t,a)=>{r();var e=n("List all environment variables that need to be set to ensure the function runs correctly. This includes any API keys, database URLs, or other configurations.");o(t,e)},$$slots:{default:!0}});var O=s(N);i(O,{children:(t,a)=>{r();var e=n("For each variable, include the following details:");o(t,e)},$$slots:{default:!0}});var G=s(O);E(G,{ordered:!1,marker:"-",children:(t,a)=>{var e=Ht(),m=p(e);_(m,{children:(f,h)=>{var l=St(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Variable name");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var P=s(m);_(P,{children:(f,h)=>{var l=Ct(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Description");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var b=s(P);_(b,{children:(f,h)=>{var l=zt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Example value");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var g=s(b);_(g,{children:(f,h)=>{var l=Ft(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Required");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var w=s(g);_(w,{children:(f,h)=>{var l=qt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Link to documentation");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}});var W=s(G);x(W,{level:2,children:(t,a)=>{r();var e=n("Entrypoint and build command");o(t,e)},$$slots:{default:!0}});var Y=s(W);i(Y,{children:(t,a)=>{r();var e=n("Specify the entry point (main file) for the function and the command needed to build it. This will help you understand how to run and deploy the function.");o(t,e)},$$slots:{default:!0}});var K=s(Y);x(K,{level:2,children:(t,a)=>{r();var e=n("Deployment configuration");o(t,e)},$$slots:{default:!0}});var J=s(K);i(J,{children:(t,a)=>{r();var e=n("Detail the configuration needed for deployment on your chosen platform. For example, if using Backrush, include:");o(t,e)},$$slots:{default:!0}});var Z=s(J);E(Z,{ordered:!1,marker:"-",children:(t,a)=>{var e=jt(),m=p(e);_(m,{children:(f,h)=>{var l=Dt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Timeout");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var P=s(m);_(P,{children:(f,h)=>{var l=Lt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Scopes");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var b=s(P);_(b,{children:(f,h)=>{var l=Rt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Execute permissions");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var g=s(b);_(g,{children:(f,h)=>{var l=Ut(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Cron");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}});var w=s(g);_(w,{children:(f,h)=>{var l=Bt(),d=p(l);y(d,{marker:"**",children:(v,u)=>{r();var c=n("Events");o(v,c)},$$slots:{default:!0}}),r(),o(f,l)},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}});var Q=s(Z);x(Q,{level:2,children:(t,a)=>{r();var e=n("Development setup");o(t,e)},$$slots:{default:!0}});var X=s(Q);i(X,{children:(t,a)=>{r();var e=Mt(),m=s(p(e));ft(m,{content:"appwrite run function"}),r(),o(t,e)},$$slots:{default:!0}});var ee=s(X);i(ee,{children:(t,a)=>{r();var e=n("Proper documentation ensures that other developers can understand and work with your code efficiently.");o(t,e)},$$slots:{default:!0}});var te=s(ee);x(te,{level:1,children:(t,a)=>{r();var e=n("Keep functions small and focused");o(t,e)},$$slots:{default:!0}});var oe=s(te);i(oe,{children:(t,a)=>{r();var e=n("Adhering to the single responsibility principle means each function should perform one task. This approach simplifies testing, debugging, and scaling. Smaller functions are easier to manage, and they can be independently updated or replaced without affecting the entire application. So, instead of having a single function that handles user registration, payment processing, and email notifications, it's better to break them down into separate functions.");o(t,e)},$$slots:{default:!0}});var re=s(oe);i(re,{children:(t,a)=>{r();var e=n("However, there are exceptions. If your function acts as an API server, you might want to consolidate multiple services into a single API function. This approach can minimize cold-start times, as the function remains warm longer due to frequent invocations. In such cases, balancing the need for focused functions with the benefits of reduced latency is key.");o(t,e)},$$slots:{default:!0}});var se=s(re);x(se,{level:1,children:(t,a)=>{r();var e=n("Choose appropriate specifications for your functions");o(t,e)},$$slots:{default:!0}});var ne=s(se);i(ne,{children:(t,a)=>{r();var e=n("Configuring the right specifications ensures that your functions have the necessary resources for optimal performance. Proper allocation balances performance and cost, helping to avoid unnecessary expenses while maintaining efficiency.");o(t,e)},$$slots:{default:!0}});var ae=s(ne);i(ae,{children:(t,a)=>{r();var e=n("For example, if your function handles image processing, it may require more resources than a function that processes text data. In such cases, allocating more CPU and RAM can enhance performance.");o(t,e)},$$slots:{default:!0}});var ie=s(ae);i(ie,{children:(t,a)=>{r();var e=Vt(),m=s(p(e));y(m,{marker:"**",children:(P,b)=>{r();var g=n("Runtime");o(P,g)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var le=s(ie);i(le,{children:(t,a)=>{T(t,{src:"/images/blog/serverless-functions/1.png",alt:"Functions-specifications"})},$$slots:{default:!0}});var de=s(le);i(de,{children:(t,a)=>{r();var e=n("This will allow you to choose the CPU and memory allocation for your function. It's important to choose the right settings based on your function's requirements to ensure optimal performance.");o(t,e)},$$slots:{default:!0}});var ue=s(de);x(ue,{level:1,children:(t,a)=>{r();var e=n("Minimize cold starts");o(t,e)},$$slots:{default:!0}});var ce=s(ue);i(ce,{children:(t,a)=>{r();var e=n("Cold starts occur when a function is invoked after being idle, causing a delay as the runtime environment initializes. This can impact the user experience by increasing latency. Minimizing cold starts ensures a smoother, more responsive application.");o(t,e)},$$slots:{default:!0}});var $e=s(ce);i($e,{children:(t,a)=>{r();var e=n("Some languages are faster at cold starts than others. Choosing the right language for your serverless functions is important, especially for user-facing functions. Compiled languages like Go or Dart typically have faster start times compared to interpreted languages. However, for interpreted languages like Node.js, Python, or PHP, you could use a build tool like ESBuild to bundle all your code into a single file. This reduces the number of files that need to be loaded and extracted during the cold start, speeding up the process.");o(t,e)},$$slots:{default:!0}});var pe=s($e);i(pe,{children:(t,a)=>{r();var e=n("You could also consider using warm-up strategies to keep functions warm and ready to respond quickly, like scheduling periodic pings to your functions. Although this may incur additional costs and could be a form of abuse on free-tier plans. So, it's essential to weigh the trade-offs and choose the best approach for your use case.");o(t,e)},$$slots:{default:!0}});var fe=s(pe);i(fe,{children:(t,a)=>{r();var e=n("Additionally, you can optimize warm starts by reusing resources between executions. For example, you can maintain a pool of database connections at a global level to avoid repeated handshakes on each request. Also, implementing caching for database queries that don't require the latest data on every invocation can help reduce latency. However, be cautious with caching as it can lead to stale data if not managed properly.");o(t,e)},$$slots:{default:!0}});var ve=s(fe);x(ve,{level:1,children:(t,a)=>{r();var e=n("Use environment variables");o(t,e)},$$slots:{default:!0}});var he=s(ve);i(he,{children:(t,a)=>{r();var e=n("Avoid hardcoding configuration values like API keys or database URLs. Instead, use environment variables to manage these configurations securely. Hardcoding sensitive information poses a security risk and reduces flexibility. Environment variables keep sensitive data out of your codebase and make it easy to change configurations without modifying code.");o(t,e)},$$slots:{default:!0}});var me=s(he);i(me,{children:(t,a)=>{r();var e=n('In Backrush, you can set environment variables for your functions in the Cloud Console. Navigate to your function settings and scroll down to the "Environment Variables" section. Here, you can add key-value pairs for your configurations. It should look like this:');o(t,e)},$$slots:{default:!0}});var _e=s(me);i(_e,{children:(t,a)=>{var e=Nt(),m=p(e);T(m,{src:"/images/blog/serverless-functions/2.png",alt:"Environment-variables"}),r(),o(t,e)},$$slots:{default:!0}});var ge=s(_e);at(ge,{content:`const apiKey = process.env.NAME_OF_YOUR_ENV_VARIABLE

`,language:"jsx",process:!0,children:(t,a)=>{r();var e=n("const apiKey = process.env.NAME_OF_YOUR_ENV_VARIABLE");o(t,e)},$$slots:{default:!0}});var ye=s(ge);i(ye,{children:(t,a)=>{r();var e=n("Depending on your runtime and programming language, the above code might look different.");o(t,e)},$$slots:{default:!0}});var Pe=s(ye);x(Pe,{level:1,children:(t,a)=>{r();var e=n("Ensure API keys are secure");o(t,e)},$$slots:{default:!0}});var xe=s(Pe);i(xe,{children:(t,a)=>{r();var e=n("Always set minimal scopes to the API keys used in your functions to maintain security. This limits access to only the necessary resources. Additionally, set an expiration date for your API keys and regularly rotate them to enhance security further. Depending on your application, you might want to rotate the keys more or less frequently, but a general recommendation is every 1-3 months.");o(t,e)},$$slots:{default:!0}});var be=s(xe);x(be,{level:1,children:(t,a)=>{r();var e=n("Manage dependencies effectively");o(t,e)},$$slots:{default:!0}});var we=s(be);i(we,{children:(t,a)=>{r();var e=n("Keep your function dependencies lean by including only necessary libraries. This will reduce deployment size, improve performance, and simplify maintenance.");o(t,e)},$$slots:{default:!0}});var ke=s(we);i(ke,{children:(t,a)=>{r();var e=n("Large deployment packages slow down the function initialization process and increase resource consumption. If a library is not essential or you only need a small part of it, consider searching for a more lightweight alternative or writing custom code.");o(t,e)},$$slots:{default:!0}});var Ae=s(ke);x(Ae,{level:1,children:(t,a)=>{r();var e=n("Implement authentication and authorization");o(t,e)},$$slots:{default:!0}});var Ie=s(Ae);i(Ie,{children:(t,a)=>{r();var e=n("Ensure only authorized users can execute your functions. Backrush provides built-in authentication and authorization features that you can leverage to secure your functions. This is important for protecting sensitive data and preventing your functions from being misused or easily exploited.");o(t,e)},$$slots:{default:!0}});var Te=s(Ie);i(Te,{children:(t,a)=>{r();var e=n("You must ensure that authorization is enforced on your serverless functions and not solely on the client side. Client-side authorization can be bypassed, leading to security vulnerabilities. Backrush Databases and Storage services can be configured to enforce access control rules. For example, you can restrict read and write access to documents by navigating to your database collection settings in the Backrush Console and setting the appropriate permissions. It looks like this:");o(t,e)},$$slots:{default:!0}});var Ee=s(Te);i(Ee,{children:(t,a)=>{T(t,{src:"/images/blog/serverless-functions/3.png",alt:"Functions-authorization"})},$$slots:{default:!0}});var Se=s(Ee);i(Se,{children:(t,a)=>{r();var e=Ot(),m=s(p(e));y(m,{marker:"**",children:(P,b)=>{r();var g=n("execute access");o(P,g)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var Ce=s(Se);i(Ce,{children:(t,a)=>{T(t,{src:"/images/blog/serverless-functions/4.png",alt:"Functions-access"})},$$slots:{default:!0}});var ze=s(Ce);x(ze,{level:1,children:(t,a)=>{r();var e=n("Encrypt sensitive data");o(t,e)},$$slots:{default:!0}});var Fe=s(ze);i(Fe,{children:(t,a)=>{r();var e=n("Always encrypt sensitive data, both in transit and at rest, to protect it from unauthorized access. Encryption ensures that even if data is intercepted or accessed by unauthorized users, it cannot be read or tampered with.");o(t,e)},$$slots:{default:!0}});var qe=s(Fe);i(qe,{children:(t,a)=>{r();var e=n("For example, if your function interacts with a database, ensure that the database connection is encrypted using SSL/TLS. Additionally, encrypt sensitive data before storing it in the database. Backrush already does a great job of applying encryption in authentication, enforcing HTTPS connections, and generating TLS certificates for domains. But in addition to that, Backrush also use encryption for storage. However, you should ensure that there are no loose ends or security loopholes in your function code that could expose sensitive data.");o(t,e)},$$slots:{default:!0}});var He=s(qe);i(He,{children:(t,a)=>{r();var e=n("In addition to encryption, consider allowing access only from specific IP ranges to enhance security. Note that encryption can impact query performance. So, you should carefully plan your encryption strategy to balance security and performance, possibly using selective encryption for highly sensitive data while ensuring efficient access to less sensitive information.");o(t,e)},$$slots:{default:!0}});var De=s(He);x(De,{level:1,children:(t,a)=>{r();var e=n("Write unit and integration tests");o(t,e)},$$slots:{default:!0}});var Le=s(De);i(Le,{children:(t,a)=>{r();var e=n("Unit tests validate individual parts of your function, while integration tests ensure that different parts of your system work together correctly. Testing catches bugs early in the development process, ensuring that your functions work as intended and reducing the likelihood of issues in production.");o(t,e)},$$slots:{default:!0}});var Re=s(Le);i(Re,{children:(t,a)=>{r();var e=n("Here's what a unit test for a function that calculates the sum of two numbers might look like:");o(t,e)},$$slots:{default:!0}});var Ue=s(Re);at(Ue,{content:`const sum = require('./sum')

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3)
})

`,language:"jsx",process:!0,children:(t,a)=>{r();var e=n(`const sum = require('./sum')

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3)
})`);o(t,e)},$$slots:{default:!0}});var Be=s(Ue);i(Be,{children:(t,a)=>{r();var e=n("For integration tests, you can use tools like Jest, Mocha, or Cypress to test the interaction between different components of your application.");o(t,e)},$$slots:{default:!0}});var je=s(Be);i(je,{children:(t,a)=>{r();var e=n("You can also include your test command as part of your build command, so your deployments run tests automatically. If you need a more complex test pipeline, you can use GitHub Actions or similar tools to manage and run your tests.");o(t,e)},$$slots:{default:!0}});var Me=s(je);x(Me,{level:1,children:(t,a)=>{r();var e=n("Use logging and monitoring tools");o(t,e)},$$slots:{default:!0}});var Ve=s(Me);i(Ve,{children:(t,a)=>{r();var e=n("Logging helps you track the execution of your functions, identify issues, and monitor performance. By logging key events and data, you can gain insights into how your functions are behaving and quickly troubleshoot problems.");o(t,e)},$$slots:{default:!0}});var Ne=s(Ve);i(Ne,{children:(t,a)=>{r();var e=n("Backrush provides built-in logging and monitoring tools that you can use to track function execution, view logs, and monitor resource usage. This helps you gain visibility into your functions' performance and ensure they are running smoothly.");o(t,e)},$$slots:{default:!0}});var Oe=s(Ne);i(Oe,{children:(t,a)=>{r();var e=n("When using Backrush Functions, you can keep your log statements within the source code and disable logging from the function settings. This allows you to re-enable logging with a single click in the future if you need to debug or monitor specific requests.");o(t,e)},$$slots:{default:!0}});var Ge=s(Oe);i(Ge,{children:(t,a)=>{T(t,{src:"/images/blog/serverless-functions/5.png",alt:"Functions-logging"})},$$slots:{default:!0}});var We=s(Ge);x(We,{level:1,children:(t,a)=>{r();var e=n("Automate deployment process");o(t,e)},$$slots:{default:!0}});var Ye=s(We);i(Ye,{children:(t,a)=>{r();var e=n("Automate your deployment process with CI/CD pipelines. This ensures consistent deployments and helps catch issues early in the development cycle.");o(t,e)},$$slots:{default:!0}});var Ke=s(Ye);i(Ke,{children:(t,a)=>{r();var e=Gt(),m=s(p(e));S(m,{href:"https://appwrite.io/docs/tooling/command-line/installation",children:(P,b)=>{r();var g=n("Backrush CLI");o(P,g)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var Je=s(Ke);x(Je,{level:1,children:(t,a)=>{r();var e=n("Version your functions");o(t,e)},$$slots:{default:!0}});var Ze=s(Je);i(Ze,{children:(t,a)=>{r();var e=n("Versioning your functions helps you manage updates and rollbacks effectively, especially when making breaking changes. By assigning version numbers to your functions, you can track changes, maintain backward compatibility, and ensure a smooth deployment process.");o(t,e)},$$slots:{default:!0}});var Qe=s(Ze);x(Qe,{level:1,children:(t,a)=>{r();var e=n("Use cost-effective architectures");o(t,e)},$$slots:{default:!0}});var Xe=s(Qe);i(Xe,{children:(t,a)=>{r();var e=n("Design your serverless architecture to minimize costs. Use event-driven models and offload heavy processing to external services to optimize resource usage and reduce expenses. For example, instead of processing tasks like image recognition within your functions, you can use specialized services like AWS Rekognition or Google Cloud Vision to handle these tasks more efficiently.");o(t,e)},$$slots:{default:!0}});var et=s(Xe);i(et,{children:(t,a)=>{r();var e=Wt(),m=s(p(e));S(m,{href:"https://appwrite.io/docs/advanced/platform/events",children:(P,b)=>{r();var g=n("Backrush Events");o(P,g)},$$slots:{default:!0}}),r(),o(t,e)},$$slots:{default:!0}});var tt=s(et);x(tt,{level:1,children:(t,a)=>{r();var e=n("Avoid long-running functions");o(t,e)},$$slots:{default:!0}});var ot=s(tt);i(ot,{children:(t,a)=>{r();var e=n("Serverless platforms have execution time limits. Avoid long-running tasks to prevent timeouts and increased costs. When a function runs for an extended period, it consumes resources and can impact the performance of other executions. So, design your functions to be short-lived and efficient. And when you notice that a function is taking too long to execute, consider breaking it down into smaller tasks.");o(t,e)},$$slots:{default:!0}});var rt=s(ot);x(rt,{level:1,children:(t,a)=>{r();var e=n("Conclusion");o(t,e)},$$slots:{default:!0}});var st=s(rt);i(st,{children:(t,a)=>{r();var e=n("By following these best practices, you can build efficient, secure, and scalable serverless functions. This enables you to fully leverage the advantages of Backrush Functions, resulting in robust and scalable solutions tailored to modern development needs.");o(t,e)},$$slots:{default:!0}});var nt=s(st);i(nt,{children:(t,a)=>{r();var e=n("Resources:");o(t,e)},$$slots:{default:!0}});var ut=s(nt);E(ut,{ordered:!1,marker:"-",children:(t,a)=>{var e=Yt(),m=p(e);_(m,{children:(g,w)=>{S(g,{href:"https://appwrite.io/docs/functions",children:(f,h)=>{r();var l=n("Backrush functions documentation");o(f,l)},$$slots:{default:!0}})},$$slots:{default:!0}});var P=s(m);_(P,{children:(g,w)=>{S(g,{href:"https://appwrite.io/docs/advanced/platform/events",children:(f,h)=>{r();var l=n("Backrush events documentation");o(f,l)},$$slots:{default:!0}})},$$slots:{default:!0}});var b=s(P);_(b,{children:(g,w)=>{S(g,{href:"https://appwrite.io/docs/environment-variables",children:(f,h)=>{r();var l=n("Backrush environment variables documentation");o(f,l)},$$slots:{default:!0}})},$$slots:{default:!0}}),o(t,e)},$$slots:{default:!0}}),$t(C),o(dt,C)},$$slots:{default:!0}}))}const Po=Object.freeze(Object.defineProperty({__proto__:null,default:Jt,frontmatter:it},Symbol.toStringTag,{value:"Module"}));export{Po as _,Jt as a};
