import{t as h,b as a,a as s}from"./Cw4I5osi.js";import"./BzVk5r6l.js";import{c as st,s as o,f as m,n as r,r as at}from"./NgVQVlRK.js";import{n as nt}from"./B4IyMRKX.js";import{H as $}from"./CXsRaEhZ.js";import"./hMT8fFzP.js";import"./NwRJ91PD.js";/* empty css        */import"./BZUG4Puk.js";import{I as Xe}from"./CmUbQthf.js";import"./D9bBQFLV.js";import{C as y}from"./DXp9_3zM.js";import{F as b}from"./OFUKRh55.js";import{L as I,I as P}from"./BhmTgGWB.js";import{P as i}from"./D8YsId2T.js";import{S as _}from"./yHjwcyUH.js";import{L as w}from"./yh4_9ChP.js";import"./POtwinrL.js";import"./CbbZjpT6.js";/* empty css        *//* empty css        */import{P as it}from"./CEkRzcqJ.js";const et={layout:"post",title:"How to optimize your Backrush project for cost and performance",description:"Learn how to optimize your Backrush project, manage resource usage, costs, and ensure smooth performance as yout application scales.",date:"2024-09-20T00:00:00.000Z",cover:"/images/blog/how-to-optimize-your-backrush-project/cover.png",timeToRead:12,author:"ebenezer-don",category:"product",featured:!1};var lt=h("In Backrush, fetching multiple documents from a database is made easy with the <!> method. This method allows you to retrieve all documents in a collection or apply filters using the Query API. Instead of making multiple requests for each document, you can fetch only the relevant data with a single request.",1),dt=h("For example, in a content management system where you need to load blog posts written by a particular author, rather than making individual requests for each document, use Backrush&#39;s <!> method with a filter:",1),ct=h("By fetching all the documents you need in one go and applying filters, you reduce the number of requests and improve performance. However, as we&#39;ll see in the next section, you should use the <!> method carefully to avoid fetching unnecessary data, else you might end up with a large dataset that could slow down your application.",1),ut=h("For more information on querying documents, the <!> provides detailed examples and options.",1),pt=h("When building real-time applications (e.g., chat apps or collaborative tools), polling APIs frequently can result in unnecessary usage and increased server load. Backrush&#39;s <!> solves this by allowing you to subscribe to events and receive updates in real time via WebSockets. This ensures that your app remains responsive without the need for constant polling.",1),ht=h("<!>: Create a document with a single column, <!>, to track updates.",1),ft=h("<!>: Use the Realtime API to monitor changes in this document. If the <!> field updates, it signals that the data has changed and needs re-fetching.",1),mt=h("<!><!>",1),$t=h("Backrush&#39;s Realtime API supports multiple channels, such as <!>, <!>, and specific <!>, ensuring updates from any part of your app. To learn more about the Realtime API, refer to the <!>.",1),vt=h("For non-sensitive or rarely changing data, client-side caching can significantly reduce server load and improve application responsiveness. Use the browser&#39;s <!> or <!> to store data that users frequently access, such as user settings, app configurations, or product lists.",1),gt=h("For example, in an e-commerce application, you could cache product categories, prices, or frequently queried data in Redis. This way, instead of hitting the database for every request, your application can retrieve data directly from Redis, which significantly improves performance for repeated requests. You can learn more about Redis in the <!>.",1),_t=h("One of the most important optimizations for file storage is <!>. Backrush allows you to compress files in your buckets using either the <!> or <!> compression algorithms. Enabling compression reduces the file size and conserves storage space, which is particularly useful for large files and media-heavy apps.",1),yt=h("<!> is a widely-used compression algorithm that offers good compression ratios for many types of files.",1),wt=h("<!> (Zstandard) is a modern, high-performance compression algorithm that provides better compression efficiency and decompression speed compared to gzip, making it a great choice for high-performance applications.",1),bt=h("<!><!>",1),Pt=h("Keep in mind that files larger than <!> are not compressed, even if compression is enabled. This is done to prevent performance bottlenecks when handling large files. Enabling compression at the bucket level not only helps reduce storage usage but also speeds up file transfers by reducing the amount of data sent over the network.",1),xt=h("While this example shows how to serve an optimized image preview, and will greatly improve load times, it will not affect the original file size in your storage. So if you want to save storage space, consider compressing and optimizing files at the time of upload. A good practice for image optimization is to use formats like <!>, which offer better compression than JPEG or PNG.",1),kt=h("For improved file delivery performance, especially in media-heavy applications, you can leverage a domain-level CDN like <!>. A CDN caches files and serves them from locations closer to your users, reducing load times and improving the overall experience without overburdening your Backrush server.",1),At=h("In addition, deploying your Backrush project in a region near your user base can further reduce latency. Currently, Backrush supports the <!>, which is great for users in Europe. We&#39;re also expanding to more regions soon, giving you even more options to optimize performance based on your audience&#39;s location.",1),It=h("To configure budget alerts, start by navigating to the <!>, then go to the <!> section and select <!>. Here, you&#39;ll find options to manage your budget. You can set a <!> to define a hard limit on your spending, and in the <!> section, you can enable notifications that trigger when your spending reaches a certain threshold. This ensures you are alerted before exceeding your desired budget.",1),zt=h("<!><!><!>",1),St=h("<article><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!><!></article>");function Dt(tt){it(tt,nt(et,{children:(rt,Ct)=>{var k=St(),z=st(k);i(z,{children:(t,n)=>{r();var e=a("As your Backrush project scales, performance and resource management become critical, not just to keep your app running smoothly, but also to avoid unexpected usage spikes. While Backrush is designed to scale effortlessly, it's important to proactively optimize your usage so you don't reach resource limits prematurely. Effective optimization helps reduce costs, improves performance, and enhances user experience without compromising on functionality.");s(t,e)},$$slots:{default:!0}});var S=o(z);i(S,{children:(t,n)=>{r();var e=a("This guide provides a detailed overview of techniques to optimize your Backrush project, covering API request management, caching strategies, file compression, image optimization, and other methods to ensure your app performs well while staying within your desired resource limits.");s(t,e)},$$slots:{default:!0}});var D=o(S);$(D,{level:1,children:(t,n)=>{r();var e=a("1. Reducing API requests: Smart querying and consolidation");s(t,e)},$$slots:{default:!0}});var C=o(D);i(C,{children:(t,n)=>{r();var e=a("Every API request consumes resources, and when requests are made inefficiently, they can consume substantial resources and increase usage costs. Here are strategies to help reduce unnecessary API calls:");s(t,e)},$$slots:{default:!0}});var q=o(C);$(q,{level:2,children:(t,n)=>{r();var e=a("Efficient use of listDocuments with queries");s(t,e)},$$slots:{default:!0}});var T=o(q);i(T,{children:(t,n)=>{r();var e=lt(),l=o(m(e));w(l,{href:"https://backrush.io/docs/references/cloud/client-web/databases#listDocuments",children:(d,p)=>{r();var c=a("listDocuments");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var N=o(T);i(N,{children:(t,n)=>{r();var e=dt(),l=o(m(e));y(l,{content:"listDocuments"}),r(),s(t,e)},$$slots:{default:!0}});var j=o(N);b(j,{content:`const blogPosts = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [Query.equal('author', 'Michael Scott')],
)
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`const blogPosts = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [Query.equal('author', 'Michael Scott')],
)`);s(t,e)},$$slots:{default:!0}});var O=o(j);i(O,{children:(t,n)=>{r();var e=ct(),l=o(m(e));y(l,{content:"listDocuments"}),r(),s(t,e)},$$slots:{default:!0}});var F=o(O);$(F,{level:2,children:(t,n)=>{r();var e=a("Optimize pagination and filtering");s(t,e)},$$slots:{default:!0}});var B=o(F);i(B,{children:(t,n)=>{r();var e=a("For applications with large datasets (e.g., e-commerce platforms with thousands of products), retrieving all data at once can overwhelm your system. Use Backrush's pagination and filtering feature to only fetch what's immediately needed.");s(t,e)},$$slots:{default:!0}});var E=o(B);i(E,{children:(t,n)=>{r();var e=a("For example, if you're loading products from a database, instead of fetching all products, fetch them in batches using pagination.");s(t,e)},$$slots:{default:!0}});var R=o(E);b(R,{content:`const firstPage = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [
    Query.equal('author', 'Meredith Palmer'),
    Query.limit(20),
    Query.offset(0),// Fetch the first 20 records
  ],
)

const secondPage = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [
    Query.equal('author', 'JaneDoe'),
    Query.limit(20),
    Query.offset(20),// Fetch the next 20 records
  ],
)
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`const firstPage = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [
    Query.equal('author', 'Meredith Palmer'),
    Query.limit(20),
    Query.offset(0),// Fetch the first 20 records
  ],
)

const secondPage = await databases.listDocuments(
  '<DATABASE_ID>',
  '<COLLECTION_ID>',
  [
    Query.equal('author', 'JaneDoe'),
    Query.limit(20),
    Query.offset(20),// Fetch the next 20 records
  ],
)`);s(t,e)},$$slots:{default:!0}});var L=o(R);i(L,{children:(t,n)=>{r();var e=a("This strategy will not only conserve bandwidth but will ensure that your queries return faster results, improving your user experience.");s(t,e)},$$slots:{default:!0}});var Q=o(L);i(Q,{children:(t,n)=>{r();var e=ut(),l=o(m(e));w(l,{href:"https://backrush.io/docs/products/databases/queries",children:(d,p)=>{r();var c=a("Backrush Queries documentation");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var J=o(Q);$(J,{level:2,children:(t,n)=>{r();var e=a("WebSockets for real-time data");s(t,e)},$$slots:{default:!0}});var W=o(J);i(W,{children:(t,n)=>{r();var e=pt(),l=o(m(e));w(l,{href:"https://backrush.io/docs/apis/realtime",children:(d,p)=>{r();var c=a("Realtime API");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var M=o(W);i(M,{children:(t,n)=>{r();var e=a("For example, you can subscribe to file upload events in real-time:");s(t,e)},$$slots:{default:!0}});var H=o(M);b(H,{content:`const unsubscribe = client.subscribe('files', (response) => {
  if (response.events.includes('buckets.*.files.*.create')) {
    console.log('New file uploaded:', response.payload)
  }
})
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`const unsubscribe = client.subscribe('files', (response) => {
  if (response.events.includes('buckets.*.files.*.create')) {
    console.log('New file uploaded:', response.payload)
  }
})`);s(t,e)},$$slots:{default:!0}});var Y=o(H);i(Y,{children:(t,n)=>{r();var e=a("In addition to handling real-time updates, Backrush's Realtime API can help decide when further requests are needed. Instead of continuously fetching data to check for updates, you can create a versioning system.");s(t,e)},$$slots:{default:!0}});var K=o(Y);I(K,{ordered:!0,marker:".",children:(t,n)=>{var e=mt(),l=m(e);P(l,{children:(p,c)=>{var v=ht(),u=m(v);_(u,{marker:"**",children:(f,x)=>{r();var A=a("Versioning Document");s(f,A)},$$slots:{default:!0}});var g=o(u,2);y(g,{content:"version"}),r(),s(p,v)},$$slots:{default:!0}});var d=o(l);P(d,{children:(p,c)=>{var v=ft(),u=m(v);_(u,{marker:"**",children:(f,x)=>{r();var A=a("Subscribe to Changes");s(f,A)},$$slots:{default:!0}});var g=o(u,2);y(g,{content:"version"}),r(),s(p,v)},$$slots:{default:!0}}),s(t,e)},$$slots:{default:!0}});var U=o(K);i(U,{children:(t,n)=>{r();var e=$t(),l=o(m(e));y(l,{content:"files"});var d=o(l,2);y(d,{content:"account"});var p=o(d,2);y(p,{content:"collections"});var c=o(p,2);w(c,{href:"https://backrush.io/docs/realtime",children:(v,u)=>{r();var g=a("Backrush Realtime documentation");s(v,g)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var G=o(U);i(G,{children:(t,n)=>{r();var e=a("By using Backrush's real-time feature, you drastically reduce API request overhead, especially for high-traffic apps like live dashboards or messaging platforms, while maintaining instant, event-driven updates.");s(t,e)},$$slots:{default:!0}});var Z=o(G);$(Z,{level:1,children:(t,n)=>{r();var e=a("2. Effective caching: Reducing redundant data fetching");s(t,e)},$$slots:{default:!0}});var V=o(Z);i(V,{children:(t,n)=>{r();var e=a("Caching is one of the most important strategies for improving both performance and resource management in your Backrush project. By caching frequently accessed data, you reduce the number of redundant requests sent to your Backrush instance.");s(t,e)},$$slots:{default:!0}});var X=o(V);$(X,{level:2,children:(t,n)=>{r();var e=a("Client-side caching with localStorage or IndexedDB");s(t,e)},$$slots:{default:!0}});var ee=o(X);i(ee,{children:(t,n)=>{r();var e=vt(),l=o(m(e));y(l,{content:"localStorage"});var d=o(l,2);y(d,{content:"IndexedDB"}),r(),s(t,e)},$$slots:{default:!0}});var te=o(ee);i(te,{children:(t,n)=>{r();var e=a("For instance, in a to-do list app, user preferences (e.g., preferred task view) can be cached locally so that the app doesn't need to retrieve this data from Backrush on every page load.");s(t,e)},$$slots:{default:!0}});var re=o(te);b(re,{content:`// Cache user preferences in localStorage
localStorage.setItem('userPreferences', JSON.stringify(preferences))

// Retrieve user preferences from cache
const cachedPreferences = JSON.parse(localStorage.getItem('userPreferences'))
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`// Cache user preferences in localStorage
localStorage.setItem('userPreferences', JSON.stringify(preferences))

// Retrieve user preferences from cache
const cachedPreferences = JSON.parse(localStorage.getItem('userPreferences'))`);s(t,e)},$$slots:{default:!0}});var oe=o(re);i(oe,{children:(t,n)=>{r();var e=a("This reduces unnecessary API requests and allows for instant access to cached data, improving performance.");s(t,e)},$$slots:{default:!0}});var se=o(oe);$(se,{level:2,children:(t,n)=>{r();var e=a("Optimized cache expiry and invalidations");s(t,e)},$$slots:{default:!0}});var ae=o(se);i(ae,{children:(t,n)=>{r();var e=a("Caching data on the client side is effective, but it must be combined with intelligent cache expiry strategies to avoid serving stale data. Ensure that the cache is invalidated and refreshed when necessary, such as when the data changes or after a certain time period.");s(t,e)},$$slots:{default:!0}});var ne=o(ae);b(ne,{content:`// Cache with expiration (using localStorage)
const saveToCache = (key, data) => {
  const item = {
    data,
    expiry: Date.now() + 1000 * 60 * 60, // Cache for 1 hour
  }
  localStorage.setItem(key, JSON.stringify(item))
}

const getFromCache = (key) => {
  const cachedItem = localStorage.getItem(key)
  if (!cachedItem) return null

  const item = JSON.parse(cachedItem)
  if (Date.now() > item.expiry) {
    localStorage.removeItem(key) // Invalidate stale cachereturn null
  }

  return item.data
}
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`// Cache with expiration (using localStorage)
const saveToCache = (key, data) => {
  const item = {
    data,
    expiry: Date.now() + 1000 * 60 * 60, // Cache for 1 hour
  }
  localStorage.setItem(key, JSON.stringify(item))
}

const getFromCache = (key) => {
  const cachedItem = localStorage.getItem(key)
  if (!cachedItem) return null

  const item = JSON.parse(cachedItem)
  if (Date.now() > item.expiry) {
    localStorage.removeItem(key) // Invalidate stale cachereturn null
  }

  return item.data
}`);s(t,e)},$$slots:{default:!0}});var ie=o(ne);i(ie,{children:(t,n)=>{r();var e=a("This ensures your users get up-to-date data while reducing the number of requests made to the server.");s(t,e)},$$slots:{default:!0}});var le=o(ie);$(le,{level:2,children:(t,n)=>{r();var e=a("Server-side caching with Redis");s(t,e)},$$slots:{default:!0}});var de=o(le);i(de,{children:(t,n)=>{r();var e=a("Redis is a widely-used, high-performance in-memory data store that can be an excellent choice for server-side caching in your Backrush projects. Redis can be deployed alongside your Backrush backend to cache frequently accessed data, reducing the load on your Backrush instance and speeding up response times for users.");s(t,e)},$$slots:{default:!0}});var ce=o(de);i(ce,{children:(t,n)=>{r();var e=gt(),l=o(m(e));w(l,{href:"https://redis.io/documentation",children:(d,p)=>{r();var c=a("Redis documentation");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var ue=o(ce);$(ue,{level:1,children:(t,n)=>{r();var e=a("3. Optimizing file storage: Compression and efficient file delivery");s(t,e)},$$slots:{default:!0}});var pe=o(ue);i(pe,{children:(t,n)=>{r();var e=a("Managing large files can be a significant source of resource consumption. Optimizing file storage and delivery can help keep storage costs down and ensure faster data transfers.");s(t,e)},$$slots:{default:!0}});var he=o(pe);$(he,{level:2,children:(t,n)=>{r();var e=a("Bucket compression");s(t,e)},$$slots:{default:!0}});var fe=o(he);i(fe,{children:(t,n)=>{r();var e=_t(),l=o(m(e));_(l,{marker:"**",children:(c,v)=>{r();var u=a("bucket compression");s(c,u)},$$slots:{default:!0}});var d=o(l,2);y(d,{content:"gzip"});var p=o(d,2);y(p,{content:"zstd"}),r(),s(t,e)},$$slots:{default:!0}});var me=o(fe);I(me,{ordered:!1,marker:"-",children:(t,n)=>{var e=bt(),l=m(e);P(l,{children:(p,c)=>{var v=yt(),u=m(v);_(u,{marker:"**",children:(g,f)=>{r();var x=a("Gzip");s(g,x)},$$slots:{default:!0}}),r(),s(p,v)},$$slots:{default:!0}});var d=o(l);P(d,{children:(p,c)=>{var v=wt(),u=m(v);_(u,{marker:"**",children:(g,f)=>{r();var x=a("Zstd");s(g,x)},$$slots:{default:!0}}),r(),s(p,v)},$$slots:{default:!0}}),s(t,e)},$$slots:{default:!0}});var $e=o(me);i($e,{children:(t,n)=>{r();var e=a("To enable compression for a bucket, you can set this up via the Backrush Console or programmatically using the SDK:");s(t,e)},$$slots:{default:!0}});var ve=o($e);b(ve,{content:`const promise = storage.createBucket('bucketId', 'bucketName', {
  compression: 'zstd',
})
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`const promise = storage.createBucket('bucketId', 'bucketName', {
  compression: 'zstd',
})`);s(t,e)},$$slots:{default:!0}});var ge=o(ve);i(ge,{children:(t,n)=>{r();var e=Pt(),l=o(m(e));_(l,{marker:"**",children:(d,p)=>{r();var c=a("20MB");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var _e=o(ge);$(_e,{level:2,children:(t,n)=>{r();var e=a("Optimizing image delivery with the Preview API");s(t,e)},$$slots:{default:!0}});var ye=o(_e);i(ye,{children:(t,n)=>{r();var e=a("Backrush allows you to serve compressed and optimized versions of your images to reduce bandwidth usage and improve performance. You can use the preview endpoint to adjust image quality, resolution, format, and more, without needing to modify the original file. This is useful for serving responsive images on the web, where you might want to reduce file sizes for faster load times.");s(t,e)},$$slots:{default:!0}});var we=o(ye);b(we,{content:`// Serve an optimized image preview
const optimizedImage = storage.getFilePreview(
  'bucketId', // The bucket ID where the file is stored
  'fileId',   // The file ID of the uploaded image
  800,        // Resize the width to 800px
  0,          // Keep the original height (aspect ratio preserved)
  'center',   // Crop the image centered if cropping is needed
  80,         // Set image quality to 80%
  0,          // No border
  '',         // No border color
  0,          // No border radius
  1,          // Full opacity
  0,          // No rotation
  '',         // No background color
  'webp',     // Convert the image to WebP format for better compression
)
`,language:"javascript",process:!0,children:(t,n)=>{r();var e=a(`// Serve an optimized image preview
const optimizedImage = storage.getFilePreview(
  'bucketId', // The bucket ID where the file is stored
  'fileId',   // The file ID of the uploaded image
  800,        // Resize the width to 800px
  0,          // Keep the original height (aspect ratio preserved)
  'center',   // Crop the image centered if cropping is needed
  80,         // Set image quality to 80%
  0,          // No border
  '',         // No border color
  0,          // No border radius
  1,          // Full opacity
  0,          // No rotation
  '',         // No background color
  'webp',     // Convert the image to WebP format for better compression
)`);s(t,e)},$$slots:{default:!0}});var be=o(we);i(be,{children:(t,n)=>{r();var e=xt(),l=o(m(e));y(l,{content:"WebP"}),r(),s(t,e)},$$slots:{default:!0}});var Pe=o(be);$(Pe,{level:2,children:(t,n)=>{r();var e=a("Optimizing file delivery with CDNs and regional project deployment");s(t,e)},$$slots:{default:!0}});var xe=o(Pe);i(xe,{children:(t,n)=>{r();var e=kt(),l=o(m(e));_(l,{marker:"**",children:(d,p)=>{r();var c=a("Cloudflare");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var ke=o(xe);i(ke,{children:(t,n)=>{r();var e=At(),l=o(m(e));_(l,{marker:"**",children:(d,p)=>{r();var c=a("FRA (Frankfurt) region");s(d,c)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var Ae=o(ke);i(Ae,{children:(t,n)=>{r();var e=a("By combining CDNs and regional project deployments, you can enhance file delivery speeds, reduce latency, and ensure a more responsive user experience.");s(t,e)},$$slots:{default:!0}});var Ie=o(Ae);$(Ie,{level:1,children:(t,n)=>{r();var e=a("4. Using serverless functions for optimized workflows");s(t,e)},$$slots:{default:!0}});var ze=o(Ie);i(ze,{children:(t,n)=>{r();var e=a("Serverless functions in Backrush are a powerful tool for optimizing resource usage. Instead of handling complex, resource-heavy operations on the client or in your core backend, offload these tasks to serverless functions that can execute asynchronously and on-demand.");s(t,e)},$$slots:{default:!0}});var Se=o(ze);i(Se,{children:(t,n)=>{r();var e=a("Tasks like generating reports, processing data, or transforming files can be offloaded to serverless functions. This approach frees up the client and backend from performing expensive computations and ensures that heavy workloads don't slow down your core application.");s(t,e)},$$slots:{default:!0}});var De=o(Se);$(De,{level:1,children:(t,n)=>{r();var e=a("5. Setting up usage limits, alerts, and budget controls");s(t,e)},$$slots:{default:!0}});var Ce=o(De);i(Ce,{children:(t,n)=>{r();var e=a("Proactively managing your resource usage in Backrush is key to avoiding unexpected overages and optimizing costs. Backrush offers built-in tools for setting up usage alerts and budget controls to help developers manage their consumption.");s(t,e)},$$slots:{default:!0}});var qe=o(Ce);$(qe,{level:2,children:(t,n)=>{r();var e=a("Budget controls");s(t,e)},$$slots:{default:!0}});var Te=o(qe);i(Te,{children:(t,n)=>{r();var e=a("You can also enable budget alerts to monitor your spending and prevent unexpected charges. For teams managing larger projects or multiple clients, setting budget limits ensures you stay within financial expectations.");s(t,e)},$$slots:{default:!0}});var Ne=o(Te);i(Ne,{children:(t,n)=>{r();var e=It(),l=o(m(e));_(l,{marker:"**",children:(u,g)=>{r();var f=a("Backrush Cloud Console");s(u,f)},$$slots:{default:!0}});var d=o(l,2);_(d,{marker:"**",children:(u,g)=>{r();var f=a("Organisation");s(u,f)},$$slots:{default:!0}});var p=o(d,2);_(p,{marker:"**",children:(u,g)=>{r();var f=a("Billing");s(u,f)},$$slots:{default:!0}});var c=o(p,2);_(c,{marker:"**",children:(u,g)=>{r();var f=a("budget cap");s(u,f)},$$slots:{default:!0}});var v=o(c,2);_(v,{marker:"**",children:(u,g)=>{r();var f=a("Budget Alerts");s(u,f)},$$slots:{default:!0}}),r(),s(t,e)},$$slots:{default:!0}});var je=o(Ne);i(je,{children:(t,n)=>{Xe(t,{src:"/images/blog/how-to-optimize-your-backrush-project/budget-controls.png",alt:"Budget controls in Backrush Cloud Console"})},$$slots:{default:!0}});var Oe=o(je);$(Oe,{level:1,children:(t,n)=>{r();var e=a("6. Monitoring and scaling your Backrush project");s(t,e)},$$slots:{default:!0}});var Fe=o(Oe);i(Fe,{children:(t,n)=>{r();var e=a("Backrush handles scalability efficiently, particularly in its cloud environment. Backrush Cloud automatically scales resources as needed, ensuring that your application can handle increased traffic or workloads without requiring manual intervention. This automatic scaling allows you to focus on building your app, while Backrush dynamically adjusts the resources behind the scenes to maintain optimal performance during traffic spikes.");s(t,e)},$$slots:{default:!0}});var Be=o(Fe);i(Be,{children:(t,n)=>{r();var e=a("While this is a significant advantage of using Backrush Cloud, self-hosted instances also provide flexibility for custom scaling configurations. By monitoring your Backrush project's resource usage, you can identify bottlenecks, optimize your app, and scale horizontally as needed.");s(t,e)},$$slots:{default:!0}});var Ee=o(Be);$(Ee,{level:2,children:(t,n)=>{r();var e=a("Automatic scaling in Backrush");s(t,e)},$$slots:{default:!0}});var Re=o(Ee);i(Re,{children:(t,n)=>{r();var e=a("Backrush's infrastructure is built on top of Docker, which allows for containerized scaling. Each service in Backrush is containerized, meaning services like databases, storage, or functions can be scaled horizontally as demand increases. This happens automatically in the cloud version of Backrush, making it easier for developers to handle surges in user traffic without experiencing downtime or performance degradation. For self-hosted Backrush, scaling is also possible but requires setting up and managing Docker containers manually.");s(t,e)},$$slots:{default:!0}});var Le=o(Re);i(Le,{children:(t,n)=>{r();var e=a("In Backrush's cloud environment, you don't have to worry about manually configuring load balancers or managing server instances to scale your application. Backrush automatically distributes workloads, ensuring smooth operation regardless of traffic volumes.");s(t,e)},$$slots:{default:!0}});var Qe=o(Le);$(Qe,{level:2,children:(t,n)=>{r();var e=a("Monitoring resource usage");s(t,e)},$$slots:{default:!0}});var Je=o(Qe);i(Je,{children:(t,n)=>{r();var e=a("Backrush provides built-in monitoring to help track API usage, database operations, storage, and other key metrics. This monitoring allows you to identify potential inefficiencies, such as high API request volumes or unnecessary data fetches, before they escalate into larger issues. While Backrush handles automatic scaling, regular monitoring can help you optimize your application to avoid overuse of resources and prevent unnecessary costs.");s(t,e)},$$slots:{default:!0}});var We=o(Je);i(We,{children:(t,n)=>{r();var e=a("You can monitor your Backrush project's performance via the dashboard, which gives insights into your API request count, database operations, and storage usage. This data helps you manage your plan limits more effectively and optimize your app to avoid unexpected scaling needs.");s(t,e)},$$slots:{default:!0}});var Me=o(We);i(Me,{children:(t,n)=>{Xe(t,{src:"/images/blog/how-to-optimize-your-backrush-project/resource-monitoring.png",alt:"Monitoring resource usage in Backrush dashboard"})},$$slots:{default:!0}});var He=o(Me);$(He,{level:2,children:(t,n)=>{r();var e=a("Horizontal scaling");s(t,e)},$$slots:{default:!0}});var Ye=o(He);i(Ye,{children:(t,n)=>{r();var e=a("For self-hosted environments, Backrush can be scaled horizontally by replicating containers across multiple servers. Stateless containers like those running functions or workers can be easily replicated to distribute workloads. However, for stateful services like databases, manual scaling configurations may be required.");s(t,e)},$$slots:{default:!0}});var Ke=o(Ye);i(Ke,{children:(t,n)=>{r();var e=a("Horizontal scaling ensures that the load is distributed evenly across multiple instances, making your application more resilient during high-traffic periods.");s(t,e)},$$slots:{default:!0}});var Ue=o(Ke);$(Ue,{level:1,children:(t,n)=>{r();var e=a("Conclusion");s(t,e)},$$slots:{default:!0}});var Ge=o(Ue);i(Ge,{children:(t,n)=>{r();var e=a("Optimizing your Backrush project ensures you not only provide a better experience to your users but also prevent unnecessary resource overuse. By applying the techniques discussed in this guide, you can keep your project running smoothly while staying within your plan limits.");s(t,e)},$$slots:{default:!0}});var Ze=o(Ge);i(Ze,{children:(t,n)=>{r();var e=a("These optimizations aren't just about cost savingsâ€”they are about making your app more scalable, efficient, and reliable as it grows. Rather than waiting until you hit plan limits, taking a proactive approach builds trust and ensures your users always experience the best possible performance, even as your app scales.");s(t,e)},$$slots:{default:!0}});var Ve=o(Ze);i(Ve,{children:(t,n)=>{r();var e=a("Further reading and resources:");s(t,e)},$$slots:{default:!0}});var ot=o(Ve);I(ot,{ordered:!1,marker:"-",children:(t,n)=>{var e=zt(),l=m(e);P(l,{children:(c,v)=>{w(c,{href:"http:backrush.io/blog/post/serverless-functions-best-practices",children:(u,g)=>{r();var f=a("Serverless functions 101: Best practices");s(u,f)},$$slots:{default:!0}})},$$slots:{default:!0}});var d=o(l);P(d,{children:(c,v)=>{w(c,{href:"https://backrush.io/docs/products/databases/queries",children:(u,g)=>{r();var f=a("Backrush Queries documentation");s(u,f)},$$slots:{default:!0}})},$$slots:{default:!0}});var p=o(d);P(p,{children:(c,v)=>{w(c,{href:"https://backrush.io/docs/products/storage/buckets",children:(u,g)=>{r();var f=a("Backrush Buckets documentation");s(u,f)},$$slots:{default:!0}})},$$slots:{default:!0}}),s(t,e)},$$slots:{default:!0}}),at(k),s(rt,k)},$$slots:{default:!0}}))}const er=Object.freeze(Object.defineProperty({__proto__:null,default:Dt,frontmatter:et},Symbol.toStringTag,{value:"Module"}));export{er as _,Dt as a};
